<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[策略模式--实现规则配置以处理任务]]></title>
    <url>%2F2018%2F11%2F05%2F%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F-%E5%AE%9E%E7%8E%B0%E8%A7%84%E5%88%99%E9%85%8D%E7%BD%AE%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[Welcome to my T-SPACE~ 由于业务需求，会有不同渠道的信息组合，现有系统设计耦合度太高，不好扩展。所以对此进行重构，添加规则配置，以应对不同组合的需求信息获取和执行。这里边用到了策略模式。 原理策略模式的概念引用阎宏博士的《JAVA与模式》一书描述：策略模式属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。 实现原理面向对象编程有三大特性：封装、继承、多态。 封装–隐藏了类的内部实现机制，对外只暴露相关的访问方法，内部实现细节对外是不可知的。 继承–对父类代码的重用。 多态–在程序中定义的引用变量所指向的具体类型，以及通过该变量而指向的方法调用有不同种类型/实现（多种形态），具体引用了什么方法要在程序运行时依据具体指向的实例对象来决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。 该策略模式的实现也是利用了多态的这一特性。 代码实现接口类123456789public interface ProcessStrategy&lt;T&gt; &#123; /** * @param result 结果集 * @param params 参数集 * @param key 结果集映射key * */ void operate(Map result, List&lt;T&gt; params, String key);&#125;` 接口实现1234567891011121314151617public class AtestProcess implements ProcessStrategy&lt;String&gt; &#123; @Override public void operate(Map result, List&lt;String&gt; params, String key) &#123; System.out.println(params.get(0)); //TODO 算法逻辑 result.put(key,"A"); &#125;&#125;public class AtestProcess implements ProcessStrategy&lt;Integer&gt; &#123; @Override public void operate(Map result, List&lt;Integer&gt; params, String key) &#123; System.out.println(params.get(0)); //TODO 算法逻辑 result.put(key,"B"); &#125;&#125; 定义工厂类定义Factory，程序运行中通过该类获取具体实例对象：12345678910111213public class ProcessFactory &#123; private static ProcessStrategy instance = null; public static ProcessStrategy getInstance(String clzName)&#123; try &#123; instance = (ProcessStrategy)Class.forName(clzName).newInstance(); &#125;catch (Exception e)&#123; System.out.println("Class not found.check the param 'clzName'. "); return null; &#125; return instance; &#125;&#125; 枚举配置通过以上代码，策略模式相关的实现大致完成，具体业务代码中使用ProcessFactory即可获取不同策略的实现方法，而要实现配置化，自动装载配置以应对不同的场景逻辑，还需要实现定义好我们的配置枚举类（配置表） 12345678910111213141516171819202122public enum TypeEnum &#123; TYPE_ENUM_A("A","com..impl.AtestProcess"), TYPE_ENUM_B("B","com..impl.BtestProcess"); private String key ; private String value; TypeEnum(String key, String value) &#123; this.key = key; this.value = value; &#125; public static String getValue(String key) &#123; for (TypeEnum typeEnum : TypeEnum.values())&#123; if (typeEnum.key.equalsIgnoreCase(key))&#123; return typeEnum.value; &#125; &#125; return null; &#125;&#125; 12345678910public String HelloTest()&#123; Map&lt;String,Object&gt; result = new HashMap&lt;&gt;(); List params = Arrays.asList("1","3","12"); String className = TypeEnum.getValue("A"); ProcessStrategy ps = ProcessFactory.getInstance(className); ps.operate(result, params, "testA"); String className = TypeEnum.getValue("B"); ps = ProcessFactory.getInstance(className); ps.operate(result, params, "testB"); &#125; 业务场景中需要走A还是走B，将条件记录于数据库/缓存redis/property文件中，当程序运行时再和TypeEnum中匹配，通过ProcessFactory捕获相应的实例对象来处理。当业务扩展，策略增多，我们只需要添加具体的接口实现，另外配置枚举对应，而不影响原来代码的主业务执行。 策略模式一方面也帮我们减少了if/else代码块过多而带来的sonar问题。]]></content>
      <categories>
        <category>Design pattern</category>
      </categories>
      <tags>
        <tag>Java|模式|多态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从0开始的小程序之旅]]></title>
    <url>%2F2018%2F10%2F18%2F%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E6%97%85%2F</url>
    <content type="text"><![CDATA[Welcome to T-SPACE~本文将介绍小程序的小白入手，从小程序的申请到小程序的开发，一起入门！ 开发工具 开发者工具 微信的开发者工具需要微信扫描登陆后才能打开。 新建项目选择小程序项目，选择代码存放的硬盘路径，填入刚刚申请到的小程序的 AppID，给你的项目起个名字，最后，勾选 “创建 QuickStart 项目” （注意: 你要选择一个空的目录才会有这个选项），点击确定，你就得到了你的第一个小程序了。 点击工具上的编译按钮，可以在工具的左侧模拟器界面看到这个小程序的表现，也可以点击预览按钮，通过微信的扫一扫在手机上体验你的第一个小程序。 小程序结构 1234567- pages --&gt; 小程序所有页面存放的文件夹- libs --&gt; 引进的js库- img --&gt; 图片文件夹1. app.json // 后缀的 JSON 配置文件2. app.wxml // 后缀的 WXML 模板文件3. app.wxss // 后缀的 WXSS 样式文件4. app.js // 后缀的 JS 脚本逻辑文件 小程序配置 app.jsonapp.json 是当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等。QuickStart 项目里边的 app.json 配置内容如下：123456789101112&amp;#123; &quot;pages&quot;:[ &quot;pages/index/index&quot;, &quot;pages/logs/logs&quot; ], &quot;window&quot;:&amp;#123; &quot;backgroundTextStyle&quot;:&quot;light&quot;, &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;, &quot;navigationBarTitleText&quot;: &quot;WeChat&quot;, &quot;navigationBarTextStyle&quot;:&quot;black&quot; &amp;#125;&amp;#125; 我们简单说一下这个配置各个项的含义: pages字段 —— 用于描述当前小程序所有页面路径，这是为了让微信客户端知道当前你的小程序页面定义在哪个目录。 window字段 —— 定义小程序所有页面的顶部背景颜色，文字颜色定义等。其他配置项细节可以参考小程序的配置 app.json。 工具配置 project.config.json通常大家在使用一个工具的时候，都会针对各自喜好做一些个性化配置，例如界面颜色、编译配置等等，当你换了另外一台电脑重新安装工具的时候，你还要重新配置。考虑到这点，小程序开发者工具在每个项目的根目录都会生成一个 project.config.json，你在工具上做的任何配置都会写入到这个文件，当你重新安装工具或者换电脑工作时，你只要载入同一个项目的代码包，开发者工具就自动会帮你恢复到当时你开发项目时的个性化配置，其中会包括编辑器的颜色、代码上传时自动压缩等等一系列选项。 页面配置 page.json与上面的app.json类似，但是是针对具体某一个页面的，让开发者可以独立定义每个页面的一些属性。 WXML 模板 编写网页时我们经常都是采用HTML+CSS+JS的组合，而WXML就相当于html，用来描述当前这个页面的结构。 在网页的一般开发流程中，我们通常会通过 JS 操作 DOM (对应 HTML 的描述产生的树)，以引起界面的一些变化响应用户的行为。例如，用户点击某个按钮的时候，JS 会记录一些状态到 JS 变量里边，同时通过 DOM API 操控 DOM 的属性或者行为，进而引起界面一些变化。当项目越来越大的时候，你的代码会充斥着非常多的界面交互逻辑和程序的各种状态变量，显然这不是一个很好的开发模式，因此就有了 MVVM 的开发模式（例如 React, Vue），提倡把渲染和逻辑分离。简单来说就是不要再让 JS 直接操控 DOM，JS 只需要管理状态即可，然后再通过一种模板语法来描述状态和界面结构的关系即可。小程序的框架也是用到了这个思路，如果你需要把一个 Hello World 的字符串显示在界面上。WXML 是这么写 :1&lt;text&gt;&amp;#123;&amp;#123;msg&amp;#125;&amp;#125;&lt;/text&gt; JS 只需要管理状态即可:1this.setData(&amp;#123; msg: &quot;Hello World&quot; &amp;#125;) 通过 &#123;&#123; &#125;&#125; 的语法把一个变量绑定到界面上，我们称为数据绑定。仅仅通过数据绑定还不够完整的描述状态和界面的关系，还需要 if/else, for等控制能力，在小程序里边，这些控制能力都用 wx: 开头的属性来表达。 WXSS 样式WXSS 具有 CSS 大部分的特性，小程序在 WXSS 也做了一些扩充和修改。新增了尺寸单位。在写 CSS 样式时，开发者需要考虑到手机设备的屏幕会有不同的宽度和设备像素比，采用一些技巧来换算一些像素单位。WXSS 在底层支持新的尺寸单位 rpx ，开发者可以免去换算的烦恼，只要交给小程序底层来换算即可，由于换算采用的浮点数运算，所以运算结果会和预期结果有一点点偏差。提供了全局的样式和局部样式。和前边 app.json, page.json 的概念相同，你可以写一个 app.wxss 作为全局样式，会作用于当前小程序的所有页面，局部页面样式 page.wxss 仅对当前页面生效。此外 WXSS 仅支持部分 CSS 选择器 JS 交互逻辑一个服务仅仅只有界面展示是不够的，还需要和用户做交互：响应用户的点击、获取用户的位置等等。在小程序里边，我们就通过编写 JS 脚本文件来处理用户的操作。12&lt;view&gt;&amp;#123;&amp;#123; msg &amp;#125;&amp;#125;&lt;/view&gt;&lt;button bindtap=&quot;clickMe&quot;&gt;点击我&lt;/button&gt; 点击 button 按钮的时候，我们希望把界面上 msg 显示成 “Hello World”，于是我们在 button 上声明一个属性: bindtap ，在 JS 文件里边声明了 clickMe 方法来响应这次点击操作：12345Page(&amp;#123; clickMe: function() &amp;#123; this.setData(&amp;#123; msg: &quot;Hello World&quot; &amp;#125;) &amp;#125;&amp;#125;) 预览使用开发者工具可以预览小程序，帮助开发者检查小程序在移动客户端上的真实表现。点击开发者工具顶部操作栏的预览按钮，开发者工具会自动打包当前项目，并上传小程序代码至微信的服务器，成功之后会在界面上显示一个二维码。使用当前小程序开发者的微信扫码即可看到小程序在手机客户端上的真实表现。 上传代码同预览不同，上传代码是用于提交体验或者审核使用的。点击开发者工具顶部操作栏的上传按钮，填写版本号以及项目备注，需要注意的是，这里版本号以及项目备注是为了方便管理员检查版本使用的，开发者可以根据自己的实际要求来填写这两个字段。上传成功之后，登录小程序管理后台 - 开发管理 - 开发版本 就可以找到刚提交上传的版本了。可以将这个版本设置 体验版 或者是 提交审核 小程序的版本 版本 说明 开发版本 使用开发者工具，可将代码上传到开发版本中。开发版本只保留每人最新的一份上传的代码。点击提交审核，可将代码提交审核。开发版本可删除，不影响线上版本和审核中版本的代码。 审核中版本 只能有一份代码处于审核中。有审核结果后可以发布到线上，也可直接重新提交审核，覆盖原审核版本。 线上版本 线上所有用户使用的代码版本，该版本代码在新版本代码发布后被覆盖更新。]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>practise|小程序|小白</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello]]></title>
    <url>%2F2018%2F09%2F13%2Fhello%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[First Blog Trip——HEXO]]></title>
    <url>%2F2018%2F01%2F18%2FfirstTitle%2F</url>
    <content type="text"><![CDATA[###HEXO常用命令： hexo init [folder] # 初始化一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站 hexo new [layout] # 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来 hexo version # 查看版本 hexo clean # 清除缓存文件 (db.json) 和已生成的静态文件 (public) hexo g # 等于hexo generate # 生成静态文件 hexo s # 等于hexo server # 本地预览 hexo d # 等于hexo deploy # 部署，可与hexo g合并为 hexo d -g ##待续。。。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>practise|blog|Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F01%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[读读HashMap(2)]]></title>
    <url>%2F2018%2F01%2F05%2F%E8%AF%BB%E8%AF%BBHashMap2%2F</url>
    <content type="text"><![CDATA[网上有很多对HashMap，HashTable几个集合类的对比与解说,看了下源码，记下笔记~ 部分内容参考：https://www.jianshu.com/p/df4a907ef4ef HashMap操作HashMap—PUT put操作，基于Java 1.6的源码如下: 12345678910111213141516171819202122232425//1.6public V put(K key, V value) &#123; //如果table数组为空数组&#123;&#125;，进行数组填充（为table分配实际内存空间），入参为threshold，此时threshold为initialCapacity 默认是1&lt;&lt;4(24=16) if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; //如果key为null，存储位置为table[0]或table[0]的冲突链上 if (key == null) return putForNullKey(value); int hash = hash(key);//对key的hashcode进一步计算，确保散列均匀 int i = indexFor(hash, table.length);//获取在table中的实际位置 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; //如果该对应数据已存在，执行覆盖操作。用新value替换旧value，并返回旧value Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++;//保证并发访问时，若HashMap内部结构发生变化，快速响应失败 addEntry(hash, key, value, i);//新增一个entry return null;&#125; 1.8之前，HashMap主干是数组与链表的结合，而后1.8版本中发生了一些改变，转变成了基于数组+链表+红黑树实现： 1.8版本 基础数组类型变成Node[]，如下： 12345678910111213141516 static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; &#125; static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; parent; // red-black tree links TreeNode&lt;K,V&gt; left; TreeNode&lt;K,V&gt; right; TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red;&#125; transient Node&lt;K,V&gt;[] table; put操作，基于Java 1.8的源码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125; final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //当前HashMap为空时，初始化数组大小 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //table数组的位置的算法是:i = (n - 1) &amp; hash，将数组长度减1后与运算hash //当计算得到的hash值为空，则新增一个节点 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; //当hash计算得到的值相同（哈希碰撞） Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //当节点为红黑树时，将结果插入到红黑树中 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; //首个链表节点为链表 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; HashMap将插入的键值对封装在Node对象中，每个Node对象含有hash值，键对象key，值对象value。当哈希值冲突后，新增的Node会被next变量指向，组成链表。当该链表的长度超过8，将其转换为红黑树节点。]]></content>
      <categories>
        <category>集合</category>
        <category>HashMap</category>
      </categories>
      <tags>
        <tag>Java|Map|集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读读HashMap(1)]]></title>
    <url>%2F2017%2F10%2F05%2F%E8%AF%BB%E8%AF%BBHashMap%2F</url>
    <content type="text"><![CDATA[网上有很多对HashMap，HashTable几个集合类的对比与解说,看了下源码，记下笔记~ 文章部分参考如下： http://www.cnblogs.com/skywang12345/p/3310835.html https://www.cnblogs.com/chengxiao/p/6059914.html HashMap基础结构HashMap的基础属性HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。12public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; HashMap底层维护的是数组+链表(链地址法),它里面有两个参数：“初始容量” 和 “加载因子”。 12345678910111213141516171819//默认的初始化大小static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16//最大的容量值，hashMap的容量大小必须是2的n次幂（2^30）static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;//负载因子static final float DEFAULT_LOAD_FACTOR = 0.75f;/** * An empty table instance to share when the table is not inflated. */static final Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;/** * The table, resized as necessary. Length MUST Always be a power of two. */transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE; DEFAULT_INITIAL_CAPACITY 即初始容量，HashMap创建时的初始容量:1&lt;&lt;4 表示 二进制的01，向左偏移4位得到 10000，转换成十进制即为16 DEFAULT_LOAD_FACTOR 即加载因子，是哈希表在其容量自动增加之前可以达到多满的一种尺度，默认为0.75。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。 HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。当发生哈希碰撞时（两个值计算得到的哈希值相同），则存储到对应下标的数组格子的链表里。（哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，而HashMap即是采用了链地址法，也就是数组+链表的方式，） HashMap的构造函数 HashMap有4种构造函数 123456789101112131415161718192021222324252627282930//以默认的初始化大小16和负载因子0.75，构造对象/** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity * (16) and the default load factor (0.75). */public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted&#125;//指定初始化大小public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;//指定容量大小和负载因子public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity);&#125;//指定mappublic HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);&#125; 在前三种构造器当中，没有为数组Entry table分配内存空间，而是在执行put操作的时候才真正构建table数组；而第四种，指定了Map，构造器中调用putMapEntries(m, false);则会构建table数组。 HashMap 原理基于Java1.6，在上面的基础信息中我们已经了解HashMap的结构，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的. 如果计算定位到的数组位置不含链表（当前entry的next指向null），那么对于查找、添加操作很快，仅需一次寻址即可，时间复杂度O(1); 如果定位到的位置包含链表，对于添加操作，首先遍历链表，存在则覆盖，否则新增，其时间复杂度O(n);对于查找操作，仍需遍历链表，逐一对比key对象查找； 所以，从性能考虑，HashMap中的链表出现越少，性能才会越好。]]></content>
      <categories>
        <category>集合</category>
        <category>HashMap</category>
      </categories>
      <tags>
        <tag>Java|Map|集合</tag>
      </tags>
  </entry>
</search>
